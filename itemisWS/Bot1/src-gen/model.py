"""Implementation of statechart model.
Generated by itemis CREATE code generator.
"""

import queue
import sys, os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../src')))

class Model:
	"""Implementation of the state machine Model.
	"""

	class State:
		""" State Enum
		"""
		(
			main_region_robot,
			main_region_robot_drive_manual,
			main_region_robot_drive_manual_r1speed,
			main_region_robot_drive_manual_r1speed_r1increase_speed,
			main_region_robot_drive_manual_r1speed_r1decrease_speed,
			main_region_robot_drive_manual_r1rotations,
			main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right,
			main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left,
			main_region_robot_drive_automatic___follow_left,
			main_region_robot_drive_automatic___follow_left_zcalibrate,
			main_region_robot_drive_automatic___follow_left_zfinished_calibration,
			main_region_robot_drive_automatic___follow_left_zforward,
			main_region_robot_drive_automatic___follow_left_zstart,
			main_region_robot_drive_automatic___follow_left_zrotating,
			main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right,
			main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target,
			main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left,
			main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot,
			main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around,
			main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw,
			main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop,
			main_region_robot_drive_stopped,
			main_region_robot_logging_and_grid_driving_start,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record,
			main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_,
			main_region_drive_to_target,
			main_region_drive_to_target_r1solved_path,
			main_region_drive_to_target_r1drive_one_step,
			main_region_drive_to_target_r1turning_to_target,
			main_region_drive_to_target_r1turn_stop,
			main_region_drive_to_target_r1go_to_center_of_new_grid,
			main_region_drive_to_target_r1check_current_grid_position,
			main_region_drive_to_target_r1_final_,
			null_state
		) = range(39)
	
	
	class UserVar:
		"""Implementation of scope UserVar.
		"""
		
		def __init__(self, statemachine):
			self.base_speed = None
			self.base_rotation = None
			self.forward_speed = None
			self.rotation_speed = None
			self.has_calibrated = None
			self.min_wall_distance = None
			self.min_wall_turn = None
			self.current_yaw = None
			self.after_turn_yaw = None
			self.target_yaw = None
			self.yaw_to_go = None
			self.total_yaw_to_go = None
			self.yaw_error = None
			self.rotation_direction = None
			self.total_distance_to_go = None
			self.distance_to_go = None
			self.center_distance_error = None
			self.last_distance = None
			self.last_yaw_to_go = None
			self.panic_mode_enable = None
			self.mapping_mode_enabled = None
			self.grid_new_x = None
			self.grid_new_y = None
			self.wall_front = None
			self.wall_left = None
			self.wall_right = None
			self.wall_back = None
			self.path_index = None
			self.target_x = None
			self.target_y = None
			self.current_x = None
			self.current_y = None
			
			self.statemachine = statemachine
		
	
	class BaseValues:
		"""Implementation of scope BaseValues.
		"""
		
		def __init__(self, statemachine):
			self.max_speed = None
			self.max_rotation = None
			self.degrees_front = None
			self.degrees_right = None
			self.degrees_back = None
			self.degrees_left = None
			
			self.statemachine = statemachine
		
	
	class Output:
		"""Implementation of scope Output.
		"""
		
		def __init__(self, statemachine):
			self.speed = None
			self.rotation = None
			self.obstacles = None
			self.gems = None
			self.finish = None
			
			self.statemachine = statemachine
		
	
	class Grid:
		"""Implementation of scope Grid.
		"""
		
		def __init__(self, statemachine):
			self.update = None
			self.receive = None
			self.column = None
			self.row = None
			self.orientation = None
			self.visited = None
			self.wall_front = None
			self.wall_right = None
			self.wall_back = None
			self.wall_left = None
			self.grid_size = None
			self.max_col = None
			self.max_row = None
			
			self.statemachine = statemachine
		
	
	class StartPos:
		"""Implementation of scope StartPos.
		"""
		
		def __init__(self, statemachine):
			self.set_zero = None
			self.zero_x = None
			self.zero_y = None
			self.zero_south_degree = None
			self.laser_deg_offset = None
			
			self.statemachine = statemachine
		
	
	class Computer:
		"""Implementation of scope Computer.
		"""
		
		def __init__(self, statemachine):
			self.m_press = None
			self.w_press = None
			self.a_press = None
			self.s_press = None
			self.d_press = None
			self.x_press = None
			self.p_press = None
			
			self.statemachine = statemachine
		
		def raise_m_press(self):
			"""Raise method for event m_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_m_press_call)
			self.statemachine.run_cycle()
		
		def __raise_m_press_call(self):
			"""Raise callback for event m_press.
			"""
			self.m_press = True
		
		def raise_w_press(self):
			"""Raise method for event w_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_w_press_call)
			self.statemachine.run_cycle()
		
		def __raise_w_press_call(self):
			"""Raise callback for event w_press.
			"""
			self.w_press = True
		
		def raise_a_press(self):
			"""Raise method for event a_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_a_press_call)
			self.statemachine.run_cycle()
		
		def __raise_a_press_call(self):
			"""Raise callback for event a_press.
			"""
			self.a_press = True
		
		def raise_s_press(self):
			"""Raise method for event s_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_s_press_call)
			self.statemachine.run_cycle()
		
		def __raise_s_press_call(self):
			"""Raise callback for event s_press.
			"""
			self.s_press = True
		
		def raise_d_press(self):
			"""Raise method for event d_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_d_press_call)
			self.statemachine.run_cycle()
		
		def __raise_d_press_call(self):
			"""Raise callback for event d_press.
			"""
			self.d_press = True
		
		def raise_x_press(self):
			"""Raise method for event x_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_x_press_call)
			self.statemachine.run_cycle()
		
		def __raise_x_press_call(self):
			"""Raise callback for event x_press.
			"""
			self.x_press = True
		
		def raise_p_press(self):
			"""Raise method for event p_press.
			"""
			self.statemachine.in_event_queue.put(self.__raise_p_press_call)
			self.statemachine.run_cycle()
		
		def __raise_p_press_call(self):
			"""Raise callback for event p_press.
			"""
			self.p_press = True
		
	
	class Imu:
		"""Implementation of scope Imu.
		"""
		
		def __init__(self, statemachine):
			self.pitch = None
			self.roll = None
			self.yaw = None
			
			self.statemachine = statemachine
		
	
	class Odom:
		"""Implementation of scope Odom.
		"""
		
		def __init__(self, statemachine):
			self.x = None
			self.y = None
			self.z = None
			
			self.statemachine = statemachine
		
	
	class LaserDistance:
		"""Implementation of scope LaserDistance.
		"""
		
		def __init__(self, statemachine):
			self.d0 = None
			self.d90 = None
			self.d180 = None
			self.dm90 = None
			self.dmin = None
			self.min_deg = None
			self.dmax = None
			self.max_deg = None
			self.dmean = None
			self.dfront_min = None
			self.min_deg_f = None
			self.dfront_max = None
			self.max_deg_f = None
			self.dfront_mean = None
			self.dright_min = None
			self.min_deg_r = None
			self.dright_max = None
			self.max_deg_r = None
			self.dright_mean = None
			self.dback_min = None
			self.min_deg_b = None
			self.dback_max = None
			self.max_deg_b = None
			self.dback_mean = None
			self.dleft_min = None
			self.min_deg_l = None
			self.dleft_max = None
			self.max_deg_l = None
			self.dleft_mean = None
			
			self.statemachine = statemachine
		
	
	class LaserIntensity:
		"""Implementation of scope LaserIntensity.
		"""
		
		def __init__(self, statemachine):
			self.i0 = None
			self.i90 = None
			self.i180 = None
			self.im90 = None
			self.ifront_min = None
			self.ifront_max = None
			self.ifront_mean = None
			self.iright_min = None
			self.iright_max = None
			self.iright_mean = None
			self.iback_min = None
			self.iback_max = None
			self.iback_mean = None
			self.ileft_min = None
			self.ileft_max = None
			self.ileft_mean = None
			
			self.statemachine = statemachine
		
	
	def __init__(self):
		""" Declares all necessary variables including list of states, histories etc. 
		"""
		self.user_var = Model.UserVar(self)
		self.base_values = Model.BaseValues(self)
		self.output = Model.Output(self)
		self.grid = Model.Grid(self)
		self.start_pos = Model.StartPos(self)
		self.computer = Model.Computer(self)
		self.imu = Model.Imu(self)
		self.odom = Model.Odom(self)
		self.laser_distance = Model.LaserDistance(self)
		self.laser_intensity = Model.LaserIntensity(self)
		
		self.__internal_event_queue = queue.Queue()
		self.in_event_queue = queue.Queue()
		self.__calibrated_yaw = None
		self.__normalized_yaw = None
		self.GRID_DIRECTION_Y = -(1)
		self.GRID_DIRECTION_X = 1
		self.__distance_to_center = None
		self.new_grid_box = None
		self.wall_stopped = None
		self.internal_operation_callback = None
		
		# enumeration of all states:
		self.__State = Model.State
		self.__state_conf_vector_changed = None
		self.__state_vector = [None] * 2
		for __state_index in range(2):
			self.__state_vector[__state_index] = self.State.null_state
		
		# for timed statechart:
		self.timer_service = None
		self.__time_events = [None] * 20
		
		# initializations:
		#Default init sequence for statechart model
		self.__calibrated_yaw = 0.0
		self.__normalized_yaw = 0
		self.__distance_to_center = 0.0
		self.user_var.base_speed = 0.05
		self.user_var.base_rotation = 0.2
		self.user_var.forward_speed = 0.1
		self.user_var.rotation_speed = 0.4
		self.user_var.has_calibrated = False
		self.user_var.min_wall_distance = 0.15
		self.user_var.min_wall_turn = 0.3
		self.user_var.current_yaw = 0.0
		self.user_var.after_turn_yaw = 0.0
		self.user_var.target_yaw = 0.0
		self.user_var.yaw_to_go = 0.0
		self.user_var.total_yaw_to_go = 0.0
		self.user_var.yaw_error = 0.2
		self.user_var.rotation_direction = 1
		self.user_var.total_distance_to_go = 0.0
		self.user_var.distance_to_go = 0.0
		self.user_var.center_distance_error = 0.02
		self.user_var.last_distance = 0.0
		self.user_var.last_yaw_to_go = 0.0
		self.user_var.panic_mode_enable = False
		self.user_var.mapping_mode_enabled = True
		self.user_var.grid_new_x = 0
		self.user_var.grid_new_y = 0
		self.user_var.wall_front = 0
		self.user_var.wall_left = 0
		self.user_var.wall_right = 0
		self.user_var.wall_back = 0
		self.user_var.path_index = 0
		self.user_var.target_x = 0
		self.user_var.target_y = 0
		self.user_var.current_x = 0.0
		self.user_var.current_y = 0.0
		self.base_values.max_speed = 0.22
		self.base_values.max_rotation = 2.84
		self.base_values.degrees_front = 40
		self.base_values.degrees_right = 40
		self.base_values.degrees_back = 40
		self.base_values.degrees_left = 40
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.output.obstacles = 0
		self.output.gems = 0
		self.output.finish = 0
		self.grid.update = False
		self.grid.receive = False
		self.grid.column = 0
		self.grid.row = 0
		self.grid.orientation = 0
		self.grid.visited = False
		self.grid.wall_front = 0
		self.grid.wall_right = 0
		self.grid.wall_back = 0
		self.grid.wall_left = 0
		self.grid.grid_size = 0.48
		self.grid.max_col = 3
		self.grid.max_row = 3
		self.start_pos.set_zero = False
		self.start_pos.zero_x = 0.0
		self.start_pos.zero_y = 0.0
		self.start_pos.zero_south_degree = 0.0
		self.start_pos.laser_deg_offset = 0
		self.imu.pitch = 0.0
		self.imu.roll = 0.0
		self.imu.yaw = 0.0
		self.odom.x = 0.0
		self.odom.y = 0.0
		self.odom.z = 0.0
		self.laser_distance.d0 = 0.0
		self.laser_distance.d90 = 0.0
		self.laser_distance.d180 = 0.0
		self.laser_distance.dm90 = 0.0
		self.laser_distance.dmin = 0.0
		self.laser_distance.min_deg = 0
		self.laser_distance.dmax = 0.0
		self.laser_distance.max_deg = 0
		self.laser_distance.dmean = 0.0
		self.laser_distance.dfront_min = 0.0
		self.laser_distance.min_deg_f = 0
		self.laser_distance.dfront_max = 0.0
		self.laser_distance.max_deg_f = 0
		self.laser_distance.dfront_mean = 0.0
		self.laser_distance.dright_min = 0.0
		self.laser_distance.min_deg_r = 0
		self.laser_distance.dright_max = 0.0
		self.laser_distance.max_deg_r = 0
		self.laser_distance.dright_mean = 0.0
		self.laser_distance.dback_min = 0.0
		self.laser_distance.min_deg_b = 0
		self.laser_distance.dback_max = 0.0
		self.laser_distance.max_deg_b = 0
		self.laser_distance.dback_mean = 0.0
		self.laser_distance.dleft_min = 0.0
		self.laser_distance.min_deg_l = 0
		self.laser_distance.dleft_max = 0.0
		self.laser_distance.max_deg_l = 0
		self.laser_distance.dleft_mean = 0.0
		self.laser_intensity.i0 = 0.0
		self.laser_intensity.i90 = 0.0
		self.laser_intensity.i180 = 0.0
		self.laser_intensity.im90 = 0.0
		self.laser_intensity.ifront_min = 0.0
		self.laser_intensity.ifront_max = 0.0
		self.laser_intensity.ifront_mean = 0.0
		self.laser_intensity.iright_min = 0.0
		self.laser_intensity.iright_max = 0.0
		self.laser_intensity.iright_mean = 0.0
		self.laser_intensity.iback_min = 0.0
		self.laser_intensity.iback_max = 0.0
		self.laser_intensity.iback_mean = 0.0
		self.laser_intensity.ileft_min = 0.0
		self.laser_intensity.ileft_max = 0.0
		self.laser_intensity.ileft_mean = 0.0
		self.__completed = False
		self.__do_completion = False
		self.__is_executing = False
		self.__state_conf_vector_position = None
	
	def is_active(self):
		"""Checks if the state machine is active.
		"""
		return self.__state_vector[0] is not self.__State.null_state or self.__state_vector[1] is not self.__State.null_state
	
	def is_final(self):
		"""Checks if the statemachine is final.
		"""
		return (self.__state_vector[0] == self.__State.main_region_drive_to_target_r1_final_) and (self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_)
								
	def is_state_active(self, state):
		"""Checks if the state is currently active.
		"""
		s = state
		if s == self.__State.main_region_robot:
			return (self.__state_vector[0] >= self.__State.main_region_robot)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_)
		if s == self.__State.main_region_robot_drive_manual:
			return (self.__state_vector[0] >= self.__State.main_region_robot_drive_manual)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left)
		if s == self.__State.main_region_robot_drive_manual_r1speed:
			return (self.__state_vector[0] >= self.__State.main_region_robot_drive_manual_r1speed)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_drive_manual_r1speed_r1decrease_speed)
		if s == self.__State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_manual_r1speed_r1increase_speed
		if s == self.__State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_manual_r1speed_r1decrease_speed
		if s == self.__State.main_region_robot_drive_manual_r1rotations:
			return (self.__state_vector[0] >= self.__State.main_region_robot_drive_manual_r1rotations)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left)
		if s == self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right
		if s == self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left
		if s == self.__State.main_region_robot_drive_automatic___follow_left:
			return (self.__state_vector[0] >= self.__State.main_region_robot_drive_automatic___follow_left)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop)
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zcalibrate:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zcalibrate
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zfinished_calibration:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zfinished_calibration
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zforward:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zforward
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zstart:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zstart
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating:
			return (self.__state_vector[0] >= self.__State.main_region_robot_drive_automatic___follow_left_zrotating)\
				and (self.__state_vector[0] <= self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop)
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw
		if s == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop
		if s == self.__State.main_region_robot_drive_stopped:
			return self.__state_vector[0] == self.__State.main_region_robot_drive_stopped
		if s == self.__State.main_region_robot_logging_and_grid_driving_start:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_start
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid:
			return (self.__state_vector[1] >= self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid)\
				and (self.__state_vector[1] <= self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_)
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record:
			return (self.__state_vector[1] >= self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record)\
				and (self.__state_vector[1] <= self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_)
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record
		if s == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
			return self.__state_vector[1] == self.__State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_
		if s == self.__State.main_region_drive_to_target:
			return (self.__state_vector[0] >= self.__State.main_region_drive_to_target)\
				and (self.__state_vector[0] <= self.__State.main_region_drive_to_target_r1_final_)
		if s == self.__State.main_region_drive_to_target_r1solved_path:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1solved_path
		if s == self.__State.main_region_drive_to_target_r1drive_one_step:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1drive_one_step
		if s == self.__State.main_region_drive_to_target_r1turning_to_target:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1turning_to_target
		if s == self.__State.main_region_drive_to_target_r1turn_stop:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1turn_stop
		if s == self.__State.main_region_drive_to_target_r1go_to_center_of_new_grid:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1go_to_center_of_new_grid
		if s == self.__State.main_region_drive_to_target_r1check_current_grid_position:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1check_current_grid_position
		if s == self.__State.main_region_drive_to_target_r1_final_:
			return self.__state_vector[0] == self.__State.main_region_drive_to_target_r1_final_
		return False
		
	def time_elapsed(self, event_id):
		"""Add time events to in event queue
		"""
		if event_id in range(20):
			self.in_event_queue.put(lambda: self.raise_time_event(event_id))
			self.run_cycle()
	
	def raise_time_event(self, event_id):
		"""Raise timed events using the event_id.
		"""
		self.__time_events[event_id] = True
	
	def __execute_queued_event(self, func):
		func()
	
	def __get_next_event(self):
		if not self.__internal_event_queue.empty():
			return self.__internal_event_queue.get()
		if not self.in_event_queue.empty():
			return self.in_event_queue.get()
		return None
	
	
	def raise_new_grid_box(self):
		"""Raise method for event new_grid_box.
		"""
		self.__internal_event_queue.put(self.__raise_new_grid_box_call)
	
	def __raise_new_grid_box_call(self):
		"""Raise callback for event new_grid_box.
		"""
		self.new_grid_box = True
	
	def raise_wall_stopped(self):
		"""Raise method for event wall_stopped.
		"""
		self.__internal_event_queue.put(self.__raise_wall_stopped_call)
	
	def __raise_wall_stopped_call(self):
		"""Raise callback for event wall_stopped.
		"""
		self.wall_stopped = True
	
	def __effect_main_region_robot_drive_automatic___follow_left_z_rotating_tr0(self):
		""".
		"""
		self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating()
		self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_forward_default()
		self.__main_region_robot_drive_automatic___follow_left_react(0)
		
	def __entry_action_main_region_robot_drive_manual_r1_speed_r1_increase_speed(self):
		"""Entry action for state 'Increase speed'..
		"""
		#Entry action for state 'Increase speed'.
		self.output.speed = (self.output.speed + self.user_var.base_speed)
		
	def __entry_action_main_region_robot_drive_manual_r1_speed_r1_decrease_speed(self):
		"""Entry action for state 'Decrease Speed'..
		"""
		#Entry action for state 'Decrease Speed'.
		self.output.speed = (self.output.speed - self.user_var.base_speed)
		
	def __entry_action_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right(self):
		"""Entry action for state 'Incr. rot. speed right'..
		"""
		#Entry action for state 'Incr. rot. speed right'.
		self.output.rotation = (self.output.rotation - (self.user_var.base_rotation / 3))
		
	def __entry_action_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left(self):
		"""Entry action for state 'Incr. rot. speed left'..
		"""
		#Entry action for state 'Incr. rot. speed left'.
		self.output.rotation = (self.output.rotation + (self.user_var.base_rotation / 3))
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_calibrate(self):
		"""Entry action for state 'calibrate'..
		"""
		#Entry action for state 'calibrate'.
		self.timer_service.set_timer(self, 0, (1 * 1000), False)
		self.timer_service.set_timer(self, 1, (3 * 1000), True)
		self.start_pos.set_zero = True
		self.internal_operation_callback.debug("Calibrating...")
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_finished_calibration(self):
		"""Entry action for state 'finished calibration'..
		"""
		#Entry action for state 'finished calibration'.
		self.timer_service.set_timer(self, 2, 100, False)
		self.internal_operation_callback.set_calibration(self.start_pos.zero_x, self.start_pos.zero_y, self.start_pos.zero_south_degree, self.start_pos.laser_deg_offset)
		self.user_var.has_calibrated = True
		self.internal_operation_callback.debug("Has Calibrated")
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_forward(self):
		"""Entry action for state 'Forward'..
		"""
		#Entry action for state 'Forward'.
		self.output.speed = self.user_var.base_speed
		self.output.rotation = 0.0
		self.internal_operation_callback.debug("STRAIGHT AHEAD NOW!")
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_start(self):
		""".
		"""
		#Entry action for state 'start'.
		self.internal_operation_callback.debug("###### ENTRY AUTOMATIC MODE #####")
		self.__completed = True
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right(self):
		"""Entry action for state 'Turn Right'..
		"""
		#Entry action for state 'Turn Right'.
		self.timer_service.set_timer(self, 3, 200, False)
		self.user_var.target_yaw = self.internal_operation_callback.orientation_to_yaw((((self.grid.orientation + 1)) % 4))
		self.user_var.rotation_direction = -(1)
		self.user_var.yaw_to_go = 90
		self.internal_operation_callback.debug("\nTURNING right")
		self.internal_operation_callback.debug_real("Current yaw", self.internal_operation_callback.relative_yaw(self.imu.yaw))
		self.internal_operation_callback.debug_real("Target yaw is going to be", self.user_var.target_yaw)
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target(self):
		"""Entry action for state 'turning to target'..
		"""
		#Entry action for state 'turning to target'.
		self.timer_service.set_timer(self, 4, 500, True)
		self.__calibrated_yaw = self.internal_operation_callback.relative_yaw(self.imu.yaw)
		self.user_var.last_yaw_to_go = self.user_var.yaw_to_go
		self.user_var.yaw_to_go = self.internal_operation_callback.abs_real(self.internal_operation_callback.calc_yaw_rotation(self.__calibrated_yaw, self.user_var.target_yaw))
		self.output.rotation = ((self.user_var.rotation_direction * self.user_var.rotation_speed) * self.internal_operation_callback.ease_out_exp(self.user_var.yaw_to_go, self.user_var.total_yaw_to_go, 2))
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left(self):
		"""Entry action for state 'Turn Left'..
		"""
		#Entry action for state 'Turn Left'.
		self.timer_service.set_timer(self, 5, 200, False)
		self.user_var.target_yaw = self.internal_operation_callback.orientation_to_yaw((((self.grid.orientation - 1)) % 4))
		self.user_var.rotation_direction = 1
		self.user_var.yaw_to_go = 90
		self.internal_operation_callback.debug("\nTURNING left")
		self.internal_operation_callback.debug_real("Current yaw (relative)", self.internal_operation_callback.relative_yaw(self.imu.yaw))
		self.internal_operation_callback.debug_real("Target yaw (relative)", self.user_var.target_yaw)
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot(self):
		"""Entry action for state 'Stop robot'..
		"""
		#Entry action for state 'Stop robot'.
		self.timer_service.set_timer(self, 6, (1 * 1000), False)
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.internal_operation_callback.debug("Stop going forward")
		self.user_var.wall_front = self.internal_operation_callback.direction_has_wall(self.laser_distance.d0)
		self.user_var.wall_left = self.internal_operation_callback.direction_has_wall(self.laser_distance.d90)
		self.user_var.wall_back = self.internal_operation_callback.direction_has_wall(self.laser_distance.d180)
		self.user_var.wall_right = self.internal_operation_callback.direction_has_wall(self.laser_distance.dm90)
		if False:
			self.internal_operation_callback.debug("Stopped - current walls")
			self.internal_operation_callback.debug_real("wallFront", self.user_var.wall_front)
			self.internal_operation_callback.debug_real("wallRight", self.user_var.wall_right)
			self.internal_operation_callback.debug_real("wallBack", self.user_var.wall_back)
			self.internal_operation_callback.debug_real("wallLeft", self.user_var.wall_left)
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around(self):
		"""Entry action for state 'Turn around'..
		"""
		#Entry action for state 'Turn around'.
		self.timer_service.set_timer(self, 7, 200, False)
		self.user_var.target_yaw = self.internal_operation_callback.orientation_to_yaw((((self.grid.orientation + 2)) % 4))
		self.user_var.rotation_direction = -(1)
		self.user_var.yaw_to_go = 180
		self.user_var.last_yaw_to_go = 360
		self.internal_operation_callback.debug("\nTURNING to go around")
		self.internal_operation_callback.debug_real("Current yaw", self.internal_operation_callback.relative_yaw(self.imu.yaw))
		self.internal_operation_callback.debug_real("Target yaw", self.user_var.target_yaw)
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw(self):
		"""Entry action for state 'set total yaw'..
		"""
		#Entry action for state 'set total yaw'.
		self.timer_service.set_timer(self, 8, 100, False)
		self.user_var.total_yaw_to_go = self.user_var.yaw_to_go
		
	def __entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop(self):
		"""Entry action for state 'TurnStop'..
		"""
		#Entry action for state 'TurnStop'.
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.internal_operation_callback.debug("Stop turning")
		
	def __entry_action_main_region_robot_drive_stopped(self):
		"""Entry action for state 'Stopped'..
		"""
		#Entry action for state 'Stopped'.
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.internal_operation_callback.debug("\n** ENTRY MANUAL MODE **\n")
		
	def __entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid(self):
		"""Entry action for state 'go to center of new grid'..
		"""
		#Entry action for state 'go to center of new grid'.
		self.timer_service.set_timer(self, 9, 200, True)
		self.internal_operation_callback.debug("Going to grid center")
		self.internal_operation_callback.debug_real("startPos.zeroX", self.start_pos.zero_x)
		self.internal_operation_callback.debug_real("startPos.zeroY", self.start_pos.zero_y)
		self.user_var.total_distance_to_go = self.internal_operation_callback.abs_real(self.internal_operation_callback.distance_to_grid_center(self.odom.x, self.odom.y))
		self.user_var.distance_to_go = (self.grid.grid_size / 2)
		self.user_var.last_distance = self.user_var.distance_to_go
		self.internal_operation_callback.debug_real("totalDistanceToGo: ", self.user_var.total_distance_to_go)
		
	def __entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid(self):
		"""Entry action for state 'raise in center new grid'..
		"""
		#Entry action for state 'raise in center new grid'.
		self.grid.column = self.user_var.grid_new_x
		self.grid.row = self.user_var.grid_new_y
		self.grid.receive = True
		self.output.speed = 0.0
		
	def __entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status(self):
		"""Entry action for state 'check status'..
		"""
		#Entry action for state 'check status'.
		self.timer_service.set_timer(self, 10, 500, True)
		
	def __entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record(self):
		"""Entry action for state 'start record'..
		"""
		#Entry action for state 'start record'.
		self.timer_service.set_timer(self, 11, (1 * 1000), False)
		self.timer_service.set_timer(self, 12, (3 * 1000), True)
		self.grid.wall_front = self.internal_operation_callback.direction_has_wall(self.laser_distance.d0)
		self.grid.wall_left = self.internal_operation_callback.direction_has_wall(self.laser_distance.d90)
		self.grid.wall_back = self.internal_operation_callback.direction_has_wall(self.laser_distance.d180)
		self.grid.wall_right = self.internal_operation_callback.direction_has_wall(self.laser_distance.dm90)
		self.grid.orientation = self.internal_operation_callback.calc_orientation(self.imu.yaw)
		self.internal_operation_callback.debug("VISUAL: Recorded walls:")
		self.internal_operation_callback.debug_real("grid column", self.grid.column)
		self.internal_operation_callback.debug_real("grid row", self.grid.row)
		self.internal_operation_callback.debug_real("wallFront", self.grid.wall_front)
		self.internal_operation_callback.debug_real("wallRight", self.grid.wall_right)
		self.internal_operation_callback.debug_real("wallBack", self.grid.wall_back)
		self.internal_operation_callback.debug_real("wallLeft", self.grid.wall_left)
		self.internal_operation_callback.debug_real("orientation", self.grid.orientation)
		self.grid.update = True
		
	def __entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_(self):
		""".
		"""
		self.__completed = True
		
	def __entry_action_main_region_drive_to_target_r1_solved_path(self):
		"""Entry action for state 'solved path'..
		"""
		#Entry action for state 'solved path'.
		self.timer_service.set_timer(self, 13, (1 * 1000), False)
		self.timer_service.set_timer(self, 14, 100, False)
		
	def __entry_action_main_region_drive_to_target_r1_drive_one_step(self):
		"""Entry action for state 'drive one step'..
		"""
		#Entry action for state 'drive one step'.
		self.timer_service.set_timer(self, 15, 200, False)
		self.timer_service.set_timer(self, 16, 100, False)
		self.output.rotation = 0.0
		self.output.speed = 0.0
		self.user_var.target_yaw = self.internal_operation_callback.get_path_step_yaw(self.user_var.path_index)
		self.user_var.rotation_direction = 1 if self.internal_operation_callback.calc_yaw_rotation(self.user_var.target_yaw, self.internal_operation_callback.relative_yaw(self.imu.yaw)) > 1 else -(1)
		self.user_var.total_yaw_to_go = self.internal_operation_callback.abs_real(self.internal_operation_callback.calc_yaw_rotation(self.internal_operation_callback.relative_yaw(self.imu.yaw), self.user_var.target_yaw))
		self.user_var.path_index = self.user_var.path_index + 1
		self.internal_operation_callback.debug("DRIVE ONE STEP")
		self.internal_operation_callback.debug_real("Rotating (total)", self.user_var.total_yaw_to_go)
		self.user_var.yaw_to_go = self.user_var.total_yaw_to_go
		self.user_var.last_yaw_to_go = self.user_var.yaw_to_go
		self.user_var.total_yaw_to_go = self.user_var.total_yaw_to_go if self.user_var.total_yaw_to_go > 90 else 90
		
	def __entry_action_main_region_drive_to_target_r1_turning_to_target(self):
		"""Entry action for state 'turning to target'..
		"""
		#Entry action for state 'turning to target'.
		self.timer_service.set_timer(self, 17, 500, True)
		self.__calibrated_yaw = self.internal_operation_callback.relative_yaw(self.imu.yaw)
		self.user_var.last_yaw_to_go = self.user_var.yaw_to_go
		self.user_var.yaw_to_go = self.internal_operation_callback.abs_real(self.internal_operation_callback.calc_yaw_rotation(self.__calibrated_yaw, self.user_var.target_yaw))
		self.output.rotation = ((self.user_var.rotation_direction * self.user_var.rotation_speed) * self.internal_operation_callback.ease_out_exp(self.user_var.yaw_to_go, self.user_var.total_yaw_to_go, 2))
		self.internal_operation_callback.debug_real("Yaw To Go", self.user_var.yaw_to_go)
		
	def __entry_action_main_region_drive_to_target_r1_turn_stop(self):
		"""Entry action for state 'TurnStop'..
		"""
		#Entry action for state 'TurnStop'.
		self.timer_service.set_timer(self, 18, 200, False)
		self.output.speed = 0.0
		self.output.rotation = 0.0
		self.user_var.total_distance_to_go = self.grid.grid_size
		self.user_var.last_distance = self.user_var.total_distance_to_go
		self.user_var.distance_to_go = self.user_var.last_distance
		if False:
			self.internal_operation_callback.debug("Stop turning")
			self.internal_operation_callback.debug_real("yaw", self.imu.yaw)
			self.internal_operation_callback.debug_real("yaw (relative)", self.internal_operation_callback.relative_yaw(self.imu.yaw))
		
	def __entry_action_main_region_drive_to_target_r1_go_to_center_of_new_grid(self):
		"""Entry action for state 'go to center of new grid'..
		"""
		#Entry action for state 'go to center of new grid'.
		self.timer_service.set_timer(self, 19, 200, True)
		self.internal_operation_callback.debug("Going to next grid center")
		self.user_var.current_x = self.odom.x
		self.user_var.current_y = self.odom.y
		self.user_var.total_distance_to_go = self.grid.grid_size
		self.user_var.distance_to_go = self.user_var.total_distance_to_go
		self.user_var.last_distance = self.user_var.distance_to_go
		
	def __entry_action_main_region_drive_to_target_r1_check_current_grid_position(self):
		"""Entry action for state 'check current grid position'..
		"""
		#Entry action for state 'check current grid position'.
		self.user_var.grid_new_x = self.internal_operation_callback.grid_position_column(self.odom.x)
		self.user_var.grid_new_y = self.internal_operation_callback.grid_position_row(self.odom.y)
		
	def __entry_action_main_region_drive_to_target_r1__final_(self):
		""".
		"""
		self.__completed = True
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_calibrate(self):
		"""Exit action for state 'calibrate'..
		"""
		#Exit action for state 'calibrate'.
		self.timer_service.unset_timer(self, 0)
		self.timer_service.unset_timer(self, 1)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_finished_calibration(self):
		"""Exit action for state 'finished calibration'..
		"""
		#Exit action for state 'finished calibration'.
		self.timer_service.unset_timer(self, 2)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right(self):
		"""Exit action for state 'Turn Right'..
		"""
		#Exit action for state 'Turn Right'.
		self.timer_service.unset_timer(self, 3)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target(self):
		"""Exit action for state 'turning to target'..
		"""
		#Exit action for state 'turning to target'.
		self.timer_service.unset_timer(self, 4)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left(self):
		"""Exit action for state 'Turn Left'..
		"""
		#Exit action for state 'Turn Left'.
		self.timer_service.unset_timer(self, 5)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot(self):
		"""Exit action for state 'Stop robot'..
		"""
		#Exit action for state 'Stop robot'.
		self.timer_service.unset_timer(self, 6)
		self.grid.orientation = self.internal_operation_callback.calc_orientation(self.imu.yaw)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around(self):
		"""Exit action for state 'Turn around'..
		"""
		#Exit action for state 'Turn around'.
		self.timer_service.unset_timer(self, 7)
		
	def __exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw(self):
		"""Exit action for state 'set total yaw'..
		"""
		#Exit action for state 'set total yaw'.
		self.timer_service.unset_timer(self, 8)
		
	def __exit_action_main_region_robot_logging_and_grid_driving_start(self):
		"""Exit action for state 'start'..
		"""
		#Exit action for state 'start'.
		self.grid.column = self.internal_operation_callback.grid_position_column(self.odom.x)
		self.grid.row = self.internal_operation_callback.grid_position_row(self.odom.y)
		self.user_var.grid_new_x = self.grid.column
		self.user_var.grid_new_y = self.grid.row
		
	def __exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid(self):
		"""Exit action for state 'go to center of new grid'..
		"""
		#Exit action for state 'go to center of new grid'.
		self.timer_service.unset_timer(self, 9)
		self.internal_operation_callback.debug("\nTRACE: center new grid")
		self.internal_operation_callback.debug_real("odom.x", self.odom.x)
		self.internal_operation_callback.debug_real("odom.y", self.odom.y)
		self.internal_operation_callback.debug_real("Distance To Go (Center gridbox)", self.user_var.distance_to_go)
		
	def __exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status(self):
		"""Exit action for state 'check status'..
		"""
		#Exit action for state 'check status'.
		self.timer_service.unset_timer(self, 10)
		
	def __exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record(self):
		"""Exit action for state 'start record'..
		"""
		#Exit action for state 'start record'.
		self.timer_service.unset_timer(self, 11)
		self.timer_service.unset_timer(self, 12)
		
	def __exit_action_main_region_drive_to_target_r1_solved_path(self):
		"""Exit action for state 'solved path'..
		"""
		#Exit action for state 'solved path'.
		self.timer_service.unset_timer(self, 13)
		self.timer_service.unset_timer(self, 14)
		
	def __exit_action_main_region_drive_to_target_r1_drive_one_step(self):
		"""Exit action for state 'drive one step'..
		"""
		#Exit action for state 'drive one step'.
		self.timer_service.unset_timer(self, 15)
		self.timer_service.unset_timer(self, 16)
		
	def __exit_action_main_region_drive_to_target_r1_turning_to_target(self):
		"""Exit action for state 'turning to target'..
		"""
		#Exit action for state 'turning to target'.
		self.timer_service.unset_timer(self, 17)
		
	def __exit_action_main_region_drive_to_target_r1_turn_stop(self):
		"""Exit action for state 'TurnStop'..
		"""
		#Exit action for state 'TurnStop'.
		self.timer_service.unset_timer(self, 18)
		
	def __exit_action_main_region_drive_to_target_r1_go_to_center_of_new_grid(self):
		"""Exit action for state 'go to center of new grid'..
		"""
		#Exit action for state 'go to center of new grid'.
		self.timer_service.unset_timer(self, 19)
		self.internal_operation_callback.debug("\nTRACE: center new grid")
		self.internal_operation_callback.debug_real("odom.x", self.odom.x)
		self.internal_operation_callback.debug_real("odom.y", self.odom.y)
		self.internal_operation_callback.debug_real("Distance To Go (Center gridbox)", self.user_var.distance_to_go)
		
	def __enter_sequence_main_region_robot_default(self):
		"""'default' enter sequence for state robot.
		"""
		#'default' enter sequence for state robot
		self.__enter_sequence_main_region_robot_drive_default()
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_default()
		
	def __enter_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed_default(self):
		"""'default' enter sequence for state Increase speed.
		"""
		#'default' enter sequence for state Increase speed
		self.__entry_action_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1speed_r1increase_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed_default(self):
		"""'default' enter sequence for state Decrease Speed.
		"""
		#'default' enter sequence for state Decrease Speed
		self.__entry_action_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_default(self):
		"""'default' enter sequence for state Incr. rot. speed right.
		"""
		#'default' enter sequence for state Incr. rot. speed right
		self.__entry_action_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_default(self):
		"""'default' enter sequence for state Incr. rot. speed left.
		"""
		#'default' enter sequence for state Incr. rot. speed left
		self.__entry_action_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_default(self):
		"""'default' enter sequence for state Automatic - Follow left.
		"""
		#'default' enter sequence for state Automatic - Follow left
		self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_default()
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate_default(self):
		"""'default' enter sequence for state calibrate.
		"""
		#'default' enter sequence for state calibrate
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_calibrate()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zcalibrate
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration_default(self):
		"""'default' enter sequence for state finished calibration.
		"""
		#'default' enter sequence for state finished calibration
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zfinished_calibration
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_forward_default(self):
		"""'default' enter sequence for state Forward.
		"""
		#'default' enter sequence for state Forward
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_forward()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zforward
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_start_default(self):
		"""'default' enter sequence for state start.
		"""
		#'default' enter sequence for state start
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_start()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zstart
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_default(self):
		"""'default' enter sequence for state rotating.
		"""
		#'default' enter sequence for state rotating
		self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_default()
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right_default(self):
		"""'default' enter sequence for state Turn Right.
		"""
		#'default' enter sequence for state Turn Right
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_default(self):
		"""'default' enter sequence for state turning to target.
		"""
		#'default' enter sequence for state turning to target
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left_default(self):
		"""'default' enter sequence for state Turn Left.
		"""
		#'default' enter sequence for state Turn Left
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_default(self):
		"""'default' enter sequence for state Stop robot.
		"""
		#'default' enter sequence for state Stop robot
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around_default(self):
		"""'default' enter sequence for state Turn around.
		"""
		#'default' enter sequence for state Turn around
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_default(self):
		"""'default' enter sequence for state set total yaw.
		"""
		#'default' enter sequence for state set total yaw
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop_default(self):
		"""'default' enter sequence for state TurnStop.
		"""
		#'default' enter sequence for state TurnStop
		self.__entry_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_drive_stopped_default(self):
		"""'default' enter sequence for state Stopped.
		"""
		#'default' enter sequence for state Stopped
		self.__entry_action_main_region_robot_drive_stopped()
		self.__state_vector[0] = self.State.main_region_robot_drive_stopped
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_start_default(self):
		"""'default' enter sequence for state start.
		"""
		#'default' enter sequence for state start
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_start
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_default(self):
		"""'default' enter sequence for state driving based on grid.
		"""
		#'default' enter sequence for state driving based on grid
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_default()
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid_default(self):
		"""'default' enter sequence for state go to center of new grid.
		"""
		#'default' enter sequence for state go to center of new grid
		self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_default(self):
		"""'default' enter sequence for state raise in center new grid.
		"""
		#'default' enter sequence for state raise in center new grid
		self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status_default(self):
		"""'default' enter sequence for state check status.
		"""
		#'default' enter sequence for state check status
		self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_default(self):
		"""'default' enter sequence for state record.
		"""
		#'default' enter sequence for state record
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_default()
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_default(self):
		"""'default' enter sequence for state start record.
		"""
		#'default' enter sequence for state start record
		self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final__default(self):
		"""Default enter sequence for final state.
		"""
		#Default enter sequence for final state
		self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_
		self.__state_conf_vector_position = 1
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_default(self):
		"""'default' enter sequence for state drive to target.
		"""
		#'default' enter sequence for state drive to target
		self.__enter_sequence_main_region_drive_to_target_r1_default()
		
	def __enter_sequence_main_region_drive_to_target_r1_solved_path_default(self):
		"""'default' enter sequence for state solved path.
		"""
		#'default' enter sequence for state solved path
		self.__entry_action_main_region_drive_to_target_r1_solved_path()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1solved_path
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1_drive_one_step_default(self):
		"""'default' enter sequence for state drive one step.
		"""
		#'default' enter sequence for state drive one step
		self.__entry_action_main_region_drive_to_target_r1_drive_one_step()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1drive_one_step
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1_turning_to_target_default(self):
		"""'default' enter sequence for state turning to target.
		"""
		#'default' enter sequence for state turning to target
		self.__entry_action_main_region_drive_to_target_r1_turning_to_target()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1turning_to_target
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1_turn_stop_default(self):
		"""'default' enter sequence for state TurnStop.
		"""
		#'default' enter sequence for state TurnStop
		self.__entry_action_main_region_drive_to_target_r1_turn_stop()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1turn_stop
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid_default(self):
		"""'default' enter sequence for state go to center of new grid.
		"""
		#'default' enter sequence for state go to center of new grid
		self.__entry_action_main_region_drive_to_target_r1_go_to_center_of_new_grid()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1go_to_center_of_new_grid
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1_check_current_grid_position_default(self):
		"""'default' enter sequence for state check current grid position.
		"""
		#'default' enter sequence for state check current grid position
		self.__entry_action_main_region_drive_to_target_r1_check_current_grid_position()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1check_current_grid_position
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_drive_to_target_r1__final__default(self):
		"""Default enter sequence for final state.
		"""
		#Default enter sequence for final state
		self.__entry_action_main_region_drive_to_target_r1__final_()
		self.__state_vector[0] = self.State.main_region_drive_to_target_r1_final_
		self.__state_conf_vector_position = 0
		self.__state_conf_vector_changed = True
		
	def __enter_sequence_main_region_default(self):
		"""'default' enter sequence for region main region.
		"""
		#'default' enter sequence for region main region
		self.__react_main_region__entry_default()
		
	def __enter_sequence_main_region_robot_drive_default(self):
		"""'default' enter sequence for region drive.
		"""
		#'default' enter sequence for region drive
		self.__react_main_region_robot_drive__entry_default()
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_default(self):
		"""'default' enter sequence for region z.
		"""
		#'default' enter sequence for region z
		self.__react_main_region_robot_drive_automatic___follow_left_z__entry_default()
		
	def __enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__entry_default()
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_default(self):
		"""'default' enter sequence for region logging and grid driving.
		"""
		#'default' enter sequence for region logging and grid driving
		self.__react_main_region_robot_logging_and_grid_driving__entry_default()
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1__entry_default()
		
	def __enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__entry_default()
		
	def __enter_sequence_main_region_drive_to_target_r1_default(self):
		"""'default' enter sequence for region r1.
		"""
		#'default' enter sequence for region r1
		self.__react_main_region_drive_to_target_r1__entry_default()
		
	def __exit_sequence_main_region_robot(self):
		"""Default exit sequence for state robot.
		"""
		#Default exit sequence for state robot
		self.__exit_sequence_main_region_robot_drive()
		self.__exit_sequence_main_region_robot_logging_and_grid_driving()
		self.__state_vector[0] = self.State.null_state
		self.__state_vector[1] = self.State.null_state
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_main_region_robot_drive_manual(self):
		"""Default exit sequence for state Manual.
		"""
		#Default exit sequence for state Manual
		self.__exit_sequence_main_region_robot_drive_manual_r1()
		self.__state_vector[0] = self.State.main_region_robot
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_speed(self):
		"""Default exit sequence for state Speed.
		"""
		#Default exit sequence for state Speed
		self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed(self):
		"""Default exit sequence for state Increase speed.
		"""
		#Default exit sequence for state Increase speed
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1speed
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed(self):
		"""Default exit sequence for state Decrease Speed.
		"""
		#Default exit sequence for state Decrease Speed
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1speed
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_rotations(self):
		"""Default exit sequence for state Rotations.
		"""
		#Default exit sequence for state Rotations
		self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1()
		self.__state_vector[0] = self.State.main_region_robot_drive_manual
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right(self):
		"""Default exit sequence for state Incr. rot. speed right.
		"""
		#Default exit sequence for state Incr. rot. speed right
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1rotations
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left(self):
		"""Default exit sequence for state Incr. rot. speed left.
		"""
		#Default exit sequence for state Incr. rot. speed left
		self.__state_vector[0] = self.State.main_region_robot_drive_manual_r1rotations
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left(self):
		"""Default exit sequence for state Automatic - Follow left.
		"""
		#Default exit sequence for state Automatic - Follow left
		self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z()
		self.__state_vector[0] = self.State.main_region_robot
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate(self):
		"""Default exit sequence for state calibrate.
		"""
		#Default exit sequence for state calibrate
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_calibrate()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration(self):
		"""Default exit sequence for state finished calibration.
		"""
		#Default exit sequence for state finished calibration
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_forward(self):
		"""Default exit sequence for state Forward.
		"""
		#Default exit sequence for state Forward
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_start(self):
		"""Default exit sequence for state start.
		"""
		#Default exit sequence for state start
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating(self):
		"""Default exit sequence for state rotating.
		"""
		#Default exit sequence for state rotating
		self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1()
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right(self):
		"""Default exit sequence for state Turn Right.
		"""
		#Default exit sequence for state Turn Right
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target(self):
		"""Default exit sequence for state turning to target.
		"""
		#Default exit sequence for state turning to target
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left(self):
		"""Default exit sequence for state Turn Left.
		"""
		#Default exit sequence for state Turn Left
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot(self):
		"""Default exit sequence for state Stop robot.
		"""
		#Default exit sequence for state Stop robot
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around(self):
		"""Default exit sequence for state Turn around.
		"""
		#Default exit sequence for state Turn around
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw(self):
		"""Default exit sequence for state set total yaw.
		"""
		#Default exit sequence for state set total yaw
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop(self):
		"""Default exit sequence for state TurnStop.
		"""
		#Default exit sequence for state TurnStop
		self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left_zrotating
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_drive_stopped(self):
		"""Default exit sequence for state Stopped.
		"""
		#Default exit sequence for state Stopped
		self.__state_vector[0] = self.State.main_region_robot
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_start(self):
		"""Default exit sequence for state start.
		"""
		#Default exit sequence for state start
		self.__state_vector[1] = self.State.main_region_robot
		self.__state_conf_vector_position = 1
		self.__exit_action_main_region_robot_logging_and_grid_driving_start()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid(self):
		"""Default exit sequence for state driving based on grid.
		"""
		#Default exit sequence for state driving based on grid
		self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1()
		self.__state_vector[1] = self.State.main_region_robot
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid(self):
		"""Default exit sequence for state go to center of new grid.
		"""
		#Default exit sequence for state go to center of new grid
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid
		self.__state_conf_vector_position = 1
		self.__exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid(self):
		"""Default exit sequence for state raise in center new grid.
		"""
		#Default exit sequence for state raise in center new grid
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status(self):
		"""Default exit sequence for state check status.
		"""
		#Default exit sequence for state check status
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid
		self.__state_conf_vector_position = 1
		self.__exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record(self):
		"""Default exit sequence for state record.
		"""
		#Default exit sequence for state record
		self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1()
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record(self):
		"""Default exit sequence for state start record.
		"""
		#Default exit sequence for state start record
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record
		self.__state_conf_vector_position = 1
		self.__exit_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_(self):
		"""Default exit sequence for final state..
		"""
		#Default exit sequence for final state.
		self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record
		self.__state_conf_vector_position = 1
		
	def __exit_sequence_main_region_drive_to_target(self):
		"""Default exit sequence for state drive to target.
		"""
		#Default exit sequence for state drive to target
		self.__exit_sequence_main_region_drive_to_target_r1()
		self.__state_vector[0] = self.State.null_state
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_drive_to_target_r1_solved_path(self):
		"""Default exit sequence for state solved path.
		"""
		#Default exit sequence for state solved path
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_drive_to_target_r1_solved_path()
		
	def __exit_sequence_main_region_drive_to_target_r1_drive_one_step(self):
		"""Default exit sequence for state drive one step.
		"""
		#Default exit sequence for state drive one step
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_drive_to_target_r1_drive_one_step()
		
	def __exit_sequence_main_region_drive_to_target_r1_turning_to_target(self):
		"""Default exit sequence for state turning to target.
		"""
		#Default exit sequence for state turning to target
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_drive_to_target_r1_turning_to_target()
		
	def __exit_sequence_main_region_drive_to_target_r1_turn_stop(self):
		"""Default exit sequence for state TurnStop.
		"""
		#Default exit sequence for state TurnStop
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_drive_to_target_r1_turn_stop()
		
	def __exit_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid(self):
		"""Default exit sequence for state go to center of new grid.
		"""
		#Default exit sequence for state go to center of new grid
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		self.__exit_action_main_region_drive_to_target_r1_go_to_center_of_new_grid()
		
	def __exit_sequence_main_region_drive_to_target_r1_check_current_grid_position(self):
		"""Default exit sequence for state check current grid position.
		"""
		#Default exit sequence for state check current grid position
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region_drive_to_target_r1__final_(self):
		"""Default exit sequence for final state..
		"""
		#Default exit sequence for final state.
		self.__state_vector[0] = self.State.main_region_drive_to_target
		self.__state_conf_vector_position = 0
		
	def __exit_sequence_main_region(self):
		"""Default exit sequence for region main region.
		"""
		#Default exit sequence for region main region
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual:
			self.__exit_sequence_main_region_robot_drive_manual()
		elif state == self.State.main_region_robot_drive_manual_r1speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
		elif state == self.State.main_region_robot_drive_manual_r1rotations:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zcalibrate:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zfinished_calibration:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zforward:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_forward()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zstart:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_start()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
		elif state == self.State.main_region_robot_drive_stopped:
			self.__exit_sequence_main_region_robot_drive_stopped()
		elif state == self.State.main_region_drive_to_target:
			self.__exit_sequence_main_region_drive_to_target()
		elif state == self.State.main_region_drive_to_target_r1solved_path:
			self.__exit_sequence_main_region_drive_to_target_r1_solved_path()
		elif state == self.State.main_region_drive_to_target_r1drive_one_step:
			self.__exit_sequence_main_region_drive_to_target_r1_drive_one_step()
		elif state == self.State.main_region_drive_to_target_r1turning_to_target:
			self.__exit_sequence_main_region_drive_to_target_r1_turning_to_target()
		elif state == self.State.main_region_drive_to_target_r1turn_stop:
			self.__exit_sequence_main_region_drive_to_target_r1_turn_stop()
		elif state == self.State.main_region_drive_to_target_r1go_to_center_of_new_grid:
			self.__exit_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid()
		elif state == self.State.main_region_drive_to_target_r1check_current_grid_position:
			self.__exit_sequence_main_region_drive_to_target_r1_check_current_grid_position()
		elif state == self.State.main_region_drive_to_target_r1_final_:
			self.__exit_sequence_main_region_drive_to_target_r1__final_()
		state = self.__state_vector[1]
		if state == self.State.main_region_robot_logging_and_grid_driving_start:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_start()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_()
		
	def __exit_sequence_main_region_robot_drive(self):
		"""Default exit sequence for region drive.
		"""
		#Default exit sequence for region drive
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual:
			self.__exit_sequence_main_region_robot_drive_manual()
		elif state == self.State.main_region_robot_drive_manual_r1speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
		elif state == self.State.main_region_robot_drive_manual_r1rotations:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zcalibrate:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zfinished_calibration:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zforward:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_forward()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zstart:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_start()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
		elif state == self.State.main_region_robot_drive_stopped:
			self.__exit_sequence_main_region_robot_drive_stopped()
		
	def __exit_sequence_main_region_robot_drive_manual_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual_r1speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
		elif state == self.State.main_region_robot_drive_manual_r1rotations:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
		
	def __exit_sequence_main_region_robot_drive_manual_r1_speed_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
		
	def __exit_sequence_main_region_robot_drive_manual_r1_rotations_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z(self):
		"""Default exit sequence for region z.
		"""
		#Default exit sequence for region z
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_automatic___follow_left_zcalibrate:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zfinished_calibration:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zforward:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_forward()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zstart:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_start()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
		
	def __exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving(self):
		"""Default exit sequence for region logging and grid driving.
		"""
		#Default exit sequence for region logging and grid driving
		state = self.__state_vector[1]
		if state == self.State.main_region_robot_logging_and_grid_driving_start:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_start()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[1]
		if state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_()
		
	def __exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[1]
		if state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
		elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final_()
		
	def __exit_sequence_main_region_drive_to_target_r1(self):
		"""Default exit sequence for region r1.
		"""
		#Default exit sequence for region r1
		state = self.__state_vector[0]
		if state == self.State.main_region_drive_to_target_r1solved_path:
			self.__exit_sequence_main_region_drive_to_target_r1_solved_path()
		elif state == self.State.main_region_drive_to_target_r1drive_one_step:
			self.__exit_sequence_main_region_drive_to_target_r1_drive_one_step()
		elif state == self.State.main_region_drive_to_target_r1turning_to_target:
			self.__exit_sequence_main_region_drive_to_target_r1_turning_to_target()
		elif state == self.State.main_region_drive_to_target_r1turn_stop:
			self.__exit_sequence_main_region_drive_to_target_r1_turn_stop()
		elif state == self.State.main_region_drive_to_target_r1go_to_center_of_new_grid:
			self.__exit_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid()
		elif state == self.State.main_region_drive_to_target_r1check_current_grid_position:
			self.__exit_sequence_main_region_drive_to_target_r1_check_current_grid_position()
		elif state == self.State.main_region_drive_to_target_r1_final_:
			self.__exit_sequence_main_region_drive_to_target_r1__final_()
		
	def __react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__choice_0(self):
		"""The reactions of state null..
		"""
		#The reactions of state null.
		if self.user_var.wall_left == 1 and self.user_var.wall_front == 1 and self.user_var.wall_right == 0:
			self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right_default()
		elif self.user_var.wall_left == 0:
			self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left_default()
		elif self.user_var.wall_left == 1 and self.user_var.wall_right == 1 and self.user_var.wall_front == 1:
			self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around_default()
		else:
			self.__react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__exit_default()
		
	def __react_main_region_drive_to_target_r1__choice_0(self):
		"""The reactions of state null..
		"""
		#The reactions of state null.
		if self.internal_operation_callback.solve_path(self.grid.column, self.grid.row):
			self.__enter_sequence_main_region_drive_to_target_r1_solved_path_default()
		else:
			self.__exit_sequence_main_region_drive_to_target()
			self.__enter_sequence_main_region_robot_default()
			self.__react(0)
		
	def __react_main_region__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_default()
		
	def __react_main_region_robot_drive_automatic___follow_left_z__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_start_default()
		
	def __react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_default()
		
	def __react_main_region_robot_drive__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_drive_stopped_default()
		
	def __react_main_region_robot_logging_and_grid_driving__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_start_default()
		
	def __react_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_default()
		
	def __react_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_default()
		
	def __react_main_region_drive_to_target_r1__entry_default(self):
		"""Default react sequence for initial entry .
		"""
		#Default react sequence for initial entry 
		self.__react_main_region_drive_to_target_r1__choice_0()
		
	def __react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__exit_default(self):
		"""The reactions of exit default..
		"""
		#The reactions of exit default.
		self.__effect_main_region_robot_drive_automatic___follow_left_z_rotating_tr0()
		
	def __react(self, transitioned_before):
		"""Implementation of __react function.
		"""
		#State machine reactions.
		return transitioned_before
	
	
	def __main_region_robot_react(self, transitioned_before):
		"""Implementation of __main_region_robot_react function.
		"""
		#The reactions of state robot.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.p_press:
					self.__exit_sequence_main_region_robot()
					self.__enter_sequence_main_region_drive_to_target_default()
					self.__react(0)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_react function.
		"""
		#The reactions of state Manual.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.s_press:
					self.__exit_sequence_main_region_robot_drive_manual()
					self.__enter_sequence_main_region_robot_drive_stopped_default()
					transitioned_after = 0
				elif self.computer.m_press:
					self.__exit_sequence_main_region_robot_drive_manual()
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_speed_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_speed_react function.
		"""
		#The reactions of state Speed.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_speed_r1_increase_speed_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_speed_r1_increase_speed_react function.
		"""
		#The reactions of state Increase speed.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.w_press) and (self.output.speed < (self.base_values.max_speed - self.user_var.base_speed)):
					self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed_default()
					self.__main_region_robot_drive_manual_r1_speed_react(0)
					transitioned_after = 0
				elif self.computer.x_press:
					self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed_default()
					self.__main_region_robot_drive_manual_r1_speed_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_r1_speed_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_speed_r1_decrease_speed_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_speed_r1_decrease_speed_react function.
		"""
		#The reactions of state Decrease Speed.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.x_press) and (self.output.speed > (-(self.base_values.max_speed) + self.user_var.base_speed)):
					self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed_default()
					self.__main_region_robot_drive_manual_r1_speed_react(0)
					transitioned_after = 0
				elif self.computer.w_press:
					self.__exit_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed_default()
					self.__main_region_robot_drive_manual_r1_speed_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_r1_speed_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_rotations_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_rotations_react function.
		"""
		#The reactions of state Rotations.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_react function.
		"""
		#The reactions of state Incr. rot. speed right.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.d_press) and (self.output.rotation > (-(self.base_values.max_rotation) + self.user_var.base_rotation)):
					self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_default()
					self.__main_region_robot_drive_manual_r1_rotations_react(0)
					transitioned_after = 0
				elif self.computer.a_press:
					self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_default()
					self.__main_region_robot_drive_manual_r1_rotations_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_r1_rotations_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_react function.
		"""
		#The reactions of state Incr. rot. speed left.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.computer.a_press) and (self.output.rotation < (self.base_values.max_rotation - self.user_var.base_rotation)):
					self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_default()
					self.__main_region_robot_drive_manual_r1_rotations_react(0)
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_default()
					self.__main_region_robot_drive_manual_r1_rotations_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_manual_r1_rotations_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_react function.
		"""
		#The reactions of state Automatic - Follow left.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.new_grid_box:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left()
					self.internal_operation_callback.debug("receiving New Grid Box")
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_default()
					transitioned_after = 0
				elif self.computer.m_press:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left()
					self.__enter_sequence_main_region_robot_drive_stopped_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_calibrate_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_calibrate_react function.
		"""
		#The reactions of state calibrate.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if (self.__time_events[0]) and (not self.start_pos.set_zero):
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate()
					self.__time_events[0] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration_default()
					self.__main_region_robot_drive_automatic___follow_left_react(0)
					transitioned_after = 0
				elif self.__time_events[1]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate()
					self.__time_events[1] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate_default()
					self.__main_region_robot_drive_automatic___follow_left_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_finished_calibration_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_finished_calibration_react function.
		"""
		#The reactions of state finished calibration.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[2]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_finished_calibration()
					self.__time_events[2] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_forward_default()
					self.__main_region_robot_drive_automatic___follow_left_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_forward_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_forward_react function.
		"""
		#The reactions of state Forward.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.dfront_mean <= self.user_var.min_wall_turn:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_forward()
					self.raise_wall_stopped()
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_default()
					self.__main_region_robot_drive_automatic___follow_left_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_start_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_start_react function.
		"""
		#The reactions of state start.
		transitioned_after = transitioned_before
		if self.__do_completion:
			#Default exit sequence for state start
			self.__state_vector[0] = self.State.main_region_robot_drive_automatic___follow_left
			self.__state_conf_vector_position = 0
			#The reactions of state null.
			if self.user_var.has_calibrated:
				self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_forward_default()
			else:
				self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_calibrate_default()
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_react function.
		"""
		#The reactions of state rotating.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right_react function.
		"""
		#The reactions of state Turn Right.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[3]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right()
					self.__time_events[3] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_react function.
		"""
		#The reactions of state turning to target.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.user_var.yaw_to_go < self.user_var.yaw_error or (self.user_var.yaw_to_go < 90 and self.user_var.last_yaw_to_go < self.user_var.yaw_to_go):
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
				elif self.__time_events[4]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target()
					self.__time_events[4] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left_react function.
		"""
		#The reactions of state Turn Left.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[5]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left()
					self.__time_events[5] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_react function.
		"""
		#The reactions of state Stop robot.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[6]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot()
					self.__time_events[6] = False
					self.__react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__choice_0()
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around_react function.
		"""
		#The reactions of state Turn around.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[7]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around()
					self.__time_events[7] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_react function.
		"""
		#The reactions of state set total yaw.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[8]:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw()
					self.__time_events[8] = False
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop_react function.
		"""
		#The reactions of state TurnStop.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.laser_distance.dfront_mean <= self.user_var.min_wall_turn:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
					self.raise_wall_stopped()
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_default()
					self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(0)
					transitioned_after = 0
				elif self.laser_distance.dfront_mean > self.user_var.min_wall_turn:
					self.__exit_sequence_main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop()
					self.__react_main_region_robot_drive_automatic___follow_left_z_rotating_r1__exit_default()
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_drive_automatic___follow_left_z_rotating_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_drive_stopped_react(self, transitioned_before):
		"""Implementation of __main_region_robot_drive_stopped_react function.
		"""
		#The reactions of state Stopped.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.computer.w_press:
					self.__exit_sequence_main_region_robot_drive_stopped()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_increase_speed_default()
					transitioned_after = 0
				elif self.computer.x_press:
					self.__exit_sequence_main_region_robot_drive_stopped()
					self.__enter_sequence_main_region_robot_drive_manual_r1_speed_r1_decrease_speed_default()
					transitioned_after = 0
				elif self.computer.d_press:
					self.__exit_sequence_main_region_robot_drive_stopped()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_default()
					transitioned_after = 0
				elif self.computer.a_press:
					self.__exit_sequence_main_region_robot_drive_stopped()
					self.__enter_sequence_main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_default()
					transitioned_after = 0
				elif self.computer.m_press:
					self.__exit_sequence_main_region_robot_drive_stopped()
					self.__enter_sequence_main_region_robot_drive_automatic___follow_left_default()
					transitioned_after = 0
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_start_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_start_react function.
		"""
		#The reactions of state start.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.has_calibrated and self.user_var.mapping_mode_enabled:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_start()
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_default()
					self.__main_region_robot_react(0)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_react function.
		"""
		#The reactions of state driving based on grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.wall_stopped:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid()
					self.internal_operation_callback.debug("Receive stopped because of wall")
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_default()
					self.__main_region_robot_react(0)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid_react function.
		"""
		#The reactions of state go to center of new grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.distance_to_go < self.user_var.center_distance_error or self.user_var.distance_to_go > self.user_var.last_distance:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid()
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_default()
					self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				if self.__time_events[9]:
					self.user_var.last_distance = self.user_var.distance_to_go
					self.user_var.distance_to_go = self.internal_operation_callback.abs_real(self.internal_operation_callback.distance_to_grid_center(self.odom.x, self.odom.y))
					self.output.speed = (self.user_var.base_speed * self.internal_operation_callback.ease_out_exp(self.user_var.distance_to_go, self.user_var.total_distance_to_go, 2))
				transitioned_after = self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_react function.
		"""
		#The reactions of state raise in center new grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if not self.grid.visited:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_default()
					self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(1)
					transitioned_after = 1
				elif self.grid.visited:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid()
					self.raise_new_grid_box()
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status_default()
					self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status_react function.
		"""
		#The reactions of state check status.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if self.user_var.grid_new_x != self.grid.column or self.user_var.grid_new_y != self.grid.row:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid_default()
					self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				if self.__time_events[10]:
					self.user_var.grid_new_x = self.internal_operation_callback.grid_position_column(self.odom.x)
					self.user_var.grid_new_y = self.internal_operation_callback.grid_position_row(self.odom.y)
				transitioned_after = self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_react function.
		"""
		#The reactions of state record.
		transitioned_after = transitioned_before
		if (self.__state_vector[1] == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_) and self.__do_completion:
			#Default exit sequence for state record
			self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1()
			self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid
			self.__state_conf_vector_position = 1
			self.raise_new_grid_box()
			self.internal_operation_callback.debug("RAISING NEW GRID")
			#'default' enter sequence for state check status
			self.__entry_action_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status()
			self.__state_vector[1] = self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status
			self.__state_conf_vector_position = 1
			self.__state_conf_vector_changed = True
			self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(1)
		else:
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_react function.
		"""
		#The reactions of state start record.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 1:
				if (self.__time_events[11]) and (not self.grid.update):
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
					self.internal_operation_callback.debug("Update false again")
					self.__time_events[11] = False
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final__default()
					transitioned_after = 1
				elif self.__time_events[12]:
					self.__exit_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record()
					self.__time_events[12] = False
					self.__enter_sequence_main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_default()
					self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_react(1)
					transitioned_after = 1
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final__react(self, transitioned_before):
		"""Implementation of __main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final__react function.
		"""
		#The reactions of state null.
		return self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_react(transitioned_before)
	
	
	def __main_region_drive_to_target_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_react function.
		"""
		#The reactions of state drive to target.
		transitioned_after = transitioned_before
		if (self.__state_vector[0] == self.State.main_region_drive_to_target_r1_final_) and self.__do_completion:
			#Default exit sequence for state drive to target
			self.__exit_sequence_main_region_drive_to_target_r1()
			self.__state_vector[0] = self.State.null_state
			self.__state_conf_vector_position = 0
			#'default' enter sequence for state robot
			self.__enter_sequence_main_region_robot_drive_default()
			self.__enter_sequence_main_region_robot_logging_and_grid_driving_default()
			self.__react(0)
		else:
			if transitioned_after < 0:
				if self.computer.m_press:
					self.__exit_sequence_main_region_drive_to_target()
					self.__enter_sequence_main_region_robot_default()
					self.__react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_solved_path_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_solved_path_react function.
		"""
		#The reactions of state solved path.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[13]:
					self.__exit_sequence_main_region_drive_to_target_r1_solved_path()
					self.__time_events[13] = False
					self.__enter_sequence_main_region_drive_to_target_r1_drive_one_step_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				if self.__time_events[14]:
					self.user_var.path_index = 0
					self.user_var.target_x = self.internal_operation_callback.get_target_x()
					self.user_var.target_y = self.internal_operation_callback.get_target_y()
					self.internal_operation_callback.debug("Path solved, going to:")
					self.internal_operation_callback.debug_real("target x", self.user_var.target_x)
					self.internal_operation_callback.debug_real("target x", self.user_var.target_y)
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_drive_one_step_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_drive_one_step_react function.
		"""
		#The reactions of state drive one step.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[15]:
					self.__exit_sequence_main_region_drive_to_target_r1_drive_one_step()
					self.__time_events[15] = False
					self.__enter_sequence_main_region_drive_to_target_r1_turning_to_target_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
				elif (self.__time_events[16]) and (self.user_var.total_yaw_to_go == 0):
					self.__exit_sequence_main_region_drive_to_target_r1_drive_one_step()
					self.__time_events[16] = False
					self.__enter_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_turning_to_target_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_turning_to_target_react function.
		"""
		#The reactions of state turning to target.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[17]:
					self.__exit_sequence_main_region_drive_to_target_r1_turning_to_target()
					self.__time_events[17] = False
					self.__enter_sequence_main_region_drive_to_target_r1_turning_to_target_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
				elif self.user_var.yaw_to_go < self.user_var.yaw_error or (self.user_var.yaw_to_go < 90 and self.user_var.last_yaw_to_go < self.user_var.yaw_to_go):
					self.__exit_sequence_main_region_drive_to_target_r1_turning_to_target()
					self.__enter_sequence_main_region_drive_to_target_r1_turn_stop_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_turn_stop_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_turn_stop_react function.
		"""
		#The reactions of state TurnStop.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.__time_events[18]:
					self.__exit_sequence_main_region_drive_to_target_r1_turn_stop()
					self.__time_events[18] = False
					self.__enter_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_go_to_center_of_new_grid_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_go_to_center_of_new_grid_react function.
		"""
		#The reactions of state go to center of new grid.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.user_var.distance_to_go < self.user_var.center_distance_error or self.user_var.distance_to_go > self.user_var.last_distance:
					self.__exit_sequence_main_region_drive_to_target_r1_go_to_center_of_new_grid()
					self.__enter_sequence_main_region_drive_to_target_r1_check_current_grid_position_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				if self.__time_events[19]:
					self.user_var.last_distance = self.user_var.distance_to_go
					self.user_var.distance_to_go = (self.grid.grid_size - self.internal_operation_callback.distance(self.odom.x, self.odom.y, self.user_var.current_x, self.user_var.current_y))
					self.internal_operation_callback.debug_real("distance to go (last)", self.user_var.last_distance)
					self.internal_operation_callback.debug_real("distance to go", self.user_var.distance_to_go)
					self.output.speed = (self.user_var.base_speed * self.internal_operation_callback.ease_out_exp(self.user_var.distance_to_go, self.user_var.total_distance_to_go, 2))
					self.internal_operation_callback.debug_real("speed", self.output.speed)
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1_check_current_grid_position_react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1_check_current_grid_position_react function.
		"""
		#The reactions of state check current grid position.
		transitioned_after = transitioned_before
		if not self.__do_completion:
			if transitioned_after < 0:
				if self.user_var.target_x == self.user_var.grid_new_x and self.user_var.target_y == self.user_var.grid_new_y:
					self.__exit_sequence_main_region_drive_to_target_r1_check_current_grid_position()
					self.internal_operation_callback.debug("FOUND THE GRID POSITION")
					self.__enter_sequence_main_region_drive_to_target_r1__final__default()
					transitioned_after = 0
				else:
					self.__exit_sequence_main_region_drive_to_target_r1_check_current_grid_position()
					self.__enter_sequence_main_region_drive_to_target_r1_drive_one_step_default()
					self.__main_region_drive_to_target_react(0)
					transitioned_after = 0
			#If no transition was taken
			if transitioned_after == transitioned_before:
				#then execute local reactions.
				transitioned_after = self.__main_region_drive_to_target_react(transitioned_before)
		return transitioned_after
	
	
	def __main_region_drive_to_target_r1__final__react(self, transitioned_before):
		"""Implementation of __main_region_drive_to_target_r1__final__react function.
		"""
		#The reactions of state null.
		return self.__main_region_drive_to_target_react(transitioned_before)
	
	
	def __clear_in_events(self):
		"""Implementation of __clear_in_events function.
		"""
		self.computer.m_press = False
		self.computer.w_press = False
		self.computer.a_press = False
		self.computer.s_press = False
		self.computer.d_press = False
		self.computer.x_press = False
		self.computer.p_press = False
		self.__time_events[0] = False
		self.__time_events[1] = False
		self.__time_events[2] = False
		self.__time_events[3] = False
		self.__time_events[4] = False
		self.__time_events[5] = False
		self.__time_events[6] = False
		self.__time_events[7] = False
		self.__time_events[8] = False
		self.__time_events[9] = False
		self.__time_events[10] = False
		self.__time_events[11] = False
		self.__time_events[12] = False
		self.__time_events[13] = False
		self.__time_events[14] = False
		self.__time_events[15] = False
		self.__time_events[16] = False
		self.__time_events[17] = False
		self.__time_events[18] = False
		self.__time_events[19] = False
	
	
	def __clear_internal_events(self):
		"""Implementation of __clear_internal_events function.
		"""
		self.new_grid_box = False
		self.wall_stopped = False
	
	
	def __micro_step(self):
		"""Implementation of __micro_step function.
		"""
		transitioned = -1
		self.__state_conf_vector_position = 0
		state = self.__state_vector[0]
		if state == self.State.main_region_robot_drive_manual_r1speed_r1increase_speed:
			transitioned = self.__main_region_robot_drive_manual_r1_speed_r1_increase_speed_react(transitioned)
		elif state == self.State.main_region_robot_drive_manual_r1speed_r1decrease_speed:
			transitioned = self.__main_region_robot_drive_manual_r1_speed_r1_decrease_speed_react(transitioned)
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_right:
			transitioned = self.__main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_right_react(transitioned)
		elif state == self.State.main_region_robot_drive_manual_r1rotations_r1incr__rot__speed_left:
			transitioned = self.__main_region_robot_drive_manual_r1_rotations_r1_incr__rot__speed_left_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zcalibrate:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_calibrate_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zfinished_calibration:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_finished_calibration_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zforward:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_forward_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zstart:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_start_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_right:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_right_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turning_to_target:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_turning_to_target_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_left:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_left_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1stop_robot:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_stop_robot_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_around:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_around_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1set_total_yaw:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_set_total_yaw_react(transitioned)
		elif state == self.State.main_region_robot_drive_automatic___follow_left_zrotating_r1turn_stop:
			transitioned = self.__main_region_robot_drive_automatic___follow_left_z_rotating_r1_turn_stop_react(transitioned)
		elif state == self.State.main_region_robot_drive_stopped:
			transitioned = self.__main_region_robot_drive_stopped_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1solved_path:
			transitioned = self.__main_region_drive_to_target_r1_solved_path_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1drive_one_step:
			transitioned = self.__main_region_drive_to_target_r1_drive_one_step_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1turning_to_target:
			transitioned = self.__main_region_drive_to_target_r1_turning_to_target_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1turn_stop:
			transitioned = self.__main_region_drive_to_target_r1_turn_stop_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1go_to_center_of_new_grid:
			transitioned = self.__main_region_drive_to_target_r1_go_to_center_of_new_grid_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1check_current_grid_position:
			transitioned = self.__main_region_drive_to_target_r1_check_current_grid_position_react(transitioned)
		elif state == self.State.main_region_drive_to_target_r1_final_:
			transitioned = self.__main_region_drive_to_target_r1__final__react(transitioned)
		if self.__state_conf_vector_position < 1:
			state = self.__state_vector[1]
			if state == self.State.main_region_robot_logging_and_grid_driving_start:
				self.__main_region_robot_logging_and_grid_driving_start_react(transitioned)
			elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1go_to_center_of_new_grid:
				self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_go_to_center_of_new_grid_react(transitioned)
			elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1raise_in_center_new_grid:
				self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_raise_in_center_new_grid_react(transitioned)
			elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1check_status:
				self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_check_status_react(transitioned)
			elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1start_record:
				self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1_start_record_react(transitioned)
			elif state == self.State.main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1record_r1_final_:
				self.__main_region_robot_logging_and_grid_driving_driving_based_on_grid_r1_record_r1__final__react(transitioned)
	
	
	def run_cycle(self):
		"""Implementation of run_cycle function.
		"""
		#Performs a 'run to completion' step.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.internal_operation_callback is None:
			raise ValueError("Internal operation callback must be set.")
		
		if self.__is_executing:
			return
		self.__is_executing = True
		next_event = self.__get_next_event()
		if next_event is not None:
			self.__execute_queued_event(next_event)
		condition_0 = True
		while condition_0:
			self.__do_completion = False
			condition_1 = True
			while condition_1:
				if self.__completed:
					self.__do_completion = True
				self.__completed = False
				self.__micro_step()
				self.__do_completion = False
				condition_1 = self.__completed
			self.__clear_in_events()
			self.__clear_internal_events()
			condition_0 = False
			next_event = self.__get_next_event()
			if next_event is not None:
				self.__execute_queued_event(next_event)
				condition_0 = True
		self.__is_executing = False
	
	
	def enter(self):
		"""Implementation of enter function.
		"""
		#Activates the state machine.
		if self.timer_service is None:
			raise ValueError('Timer service must be set.')
		
		if self.internal_operation_callback is None:
			raise ValueError("Internal operation callback must be set.")
		
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default enter sequence for statechart model
		self.__enter_sequence_main_region_default()
		self.__do_completion = False
		condition_0 = True
		while condition_0:
			if self.__completed:
				self.__do_completion = True
			self.__completed = False
			self.__micro_step()
			self.__do_completion = False
			condition_0 = self.__completed
		self.__is_executing = False
	
	
	def exit(self):
		"""Implementation of exit function.
		"""
		#Deactivates the state machine.
		if self.__is_executing:
			return
		self.__is_executing = True
		#Default exit sequence for statechart model
		self.__exit_sequence_main_region()
		self.__state_vector[0] = self.State.null_state
		self.__state_vector[1] = self.State.null_state
		self.__state_conf_vector_position = 1
		self.__is_executing = False
	
	
	def trigger_without_event(self):
		"""Implementation of triggerWithoutEvent function.
		"""
		self.run_cycle()
	
